# 数值计算 {#第四章-数值计算}

机器学习通常需要大量的数值计算。通过迭代更新估计的过程来解决数学问题，而不去求得一个公式化的结果。通常的操作包括优化和求解线性方程系统。对于采用有限的记忆储存的不能精确表述的问题，即使是估计在数值计算机上估计一个函数方程的2解都是很困难的。（注，MNIST，Mixed National Institute of Standards and Technology database，国家标准与技术研究所的数据库）。

## Overflow and Underflow 上溢出和下溢出 {#overflow-and-underflow-上溢出和下溢出}

困难之处在于采用有限位模式来在数字计算机展示连续的数学模式，在大多数情况下，都是舍入误差。其中的一种溢出就是下溢出，因为在数字接近于零时会被舍入到零。另一种比较恶劣的数值误差就是上溢出，就是数字比较大，接近于正负无穷，一般的算法都会把它当成非字符处理。说道这里就举了一个例子softmax function，softmax是logic回归的扩展，将二分类问题扩展到多分类问题 ，这个函数就需要避免 这两种方式带来的误差。下溢出还会导致表达式整体估计到零。解决的方式类似于变量代换softmax（z）=x-max\(Xi\_X\_i\)。 底层的开发这在做深度学习算法的时候应该将数值问题铭记于心。

## Poor Conditioning {#poor-conditioning}

Conditioning 反映了一个函数随着输入的改变的改变快慢程度。输入的小改变带来的Function的快速变化会增加科学计算的量，因为舍入误差会给输出带来很大的影响。举例一个能够进行特征根分解的condition number。

## Gradient-Based Optimization {#gradient-based-optimization}

通常我们的操作就是最大化或者最小化某个函数，最大化可以转化为最小化其相反数。需要进行最大或者最小化的函数被称作objective function or criterion 当然也可以称作为cost function，loss function，error function。 梯度是微积分中的概念，在导数为零的点，不能提供继续行走的critical points or stationary points。然后给出了局部最小和局部最大的定义，学习过高等数学理解都没有问题。在critical piont中有一类saddle points，是转折的点，saddle point的周围，那么是不是可以将概率论的内容应用到优化当中去，能够在一定程度上判断舍得，比直接使劲算效果可能好些，比如计算了某一个区域，感觉不是最小值存在的区域。对于多个输入，涉及到了偏导数partial derivatives。随后给出了方向导数directional derivatives，方向导数就是给出了在这个方向上的slope。所以要想最小化的函数_f_,那么就要找到下降最快的方向。下降的步长取决于Learning rate，一般可以设置为一个小的常值，也可以采用多个Learning rate进行估计，选择一个能使目标函数最小的。

## Jacobian and Hessian Matrices {#jacobian-and-hessian-matrices}

在向量分析中, 雅可比矩阵是一阶偏导数以一定方式排列成的矩阵, 其行列式称为雅可比行列式. 还有, 在代数几何中, 代数曲线的雅可比量表示雅可比簇：伴随该曲线的一个代数群, 曲线可以嵌入其中. 它们全部都以数学家卡尔·雅可比\(Carl Jacob, 1804年10月4日－1851年2月18日\)命名。雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近. 因此, 雅可比矩阵类似于多元函数的导数。 在数学中, 海森矩阵\(Hessian matrix或Hessian\)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 一般来说, 牛顿法主要应用在两个方面, 1, 求方程的根; 2, 最优化.

1. 结合牛顿法，采用海森矩阵，使用迭代法可以求解方程的根；
2. 在最优化的问题中, 线性最优化至少可以使用单纯形法\(或称不动点算法\)求解, 但对于非线性优化问题, 牛顿法提供了一种求解的办法. 假设任务是优化一个目标函数f, 求函数f的极大极小问题, 可以转化为求解函数f的导数f′=0的问题, 这样求可以把优化问题看成方程求解问题\(f′=0\). 剩下的问题就和第一部分提到的牛顿法求解很相似了 在求得一阶导数的情况下，还可以求出二阶导数。对于多维的情况，我们需要验证所有的二阶导数。针对海森矩阵，进行特征分解，就可以验证二阶导数。只采用了梯度，就叫做梯度一阶优化方法，如果采用了海森矩阵比如牛顿方法就叫做二阶优化。 在在数学中，特别是实分析，利普希茨连续（Lipschitz continuity）以德国数学家鲁道夫·利普希茨命名，是一个比通常连续更强的光滑性条件。直觉上，利普希茨连续函数限制了函数改变的速度，符合利普希茨条件的函数的斜率，必小于一个称为利普希茨常数的实数（该常数依函数而定）。在深度学习中，对于我们的目标函数，通常增加限制条件Lipchitz continuity，或者利普希茨条件的离散。这个条件保证了小的输入对输出的改变很小。利普希茨约束在深度学习当中任然是一个比较弱的约束，所以在实际适应的时候回做出相应的修改。 凸优化可能是最成功的方法，但是在深度学习的情况下，凸优化的重要性在下降。

## Constrained Optimization 约束优化 {#constrained-optimization-约束优化}

约束优化法（ConstrainedOptimizationMethod）：约束优化问题是在自变量满足约束条件的情况下目标函数最小化的问题，其中约束条件既可以是等式约束也可以是不等式约束。实际就是约束条件下的优化，这个条件下的解就是feasibel point（可行解）。 这里讲了约束的表示方法的问题，需要一些创造性，例如要求绝对值小于1的变量可以转化为三角函数表示，这样就方便了很多，具体怎么用主要是看实际操作和使用者的创造能力。 在求取有约束条件的优化问题时，拉格朗日乘子法（Lagrange Multiplier\) 和KKT条件是非常重要的两个求取方法，对于等式约束的优化问题，可以应用拉格朗日乘子法去求取最优值；如果含有不等式约束，可以应用KKT条件去求取。当然，这两个方法求得的结果只是必要条件，只有当是凸函数的情况下，才能保证是充分必要条件。KKT条件是拉格朗日乘子法的泛化。 常用的方法是KKT条件（卡罗需－庫恩－塔克条件，Karush–Kuhn–Tucker），同样地，把所有的不等式约束、等式约束和目标函数全部写为一个式子$$L(a, b, x)= f(x) + a_g(x)+b_h(x)$$，KKT条件是说最优值必须满足以下条件：

1. L\(a, b, x\)对x求导为零；
2. h\(x\) =0;
3. a\*g\(x\) = 0; 采用KKT条件可以构建广义的拉格朗日方程（generalized Lagrangian or generalized Lagrange function）.




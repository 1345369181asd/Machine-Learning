最小二乘法是用来做函数拟合或者求函数极值的方法。在机器学习，尤其是回归模型中，经常可以看到最小二乘法的身影，这里就对我对最小二乘法的认知做一个小结。

# 1.最小二乘法的原理与要解决的问题

最小二乘法是由勒让德在19世纪发现的，原理的一般形式很简单，当然发现的过程是非常艰难的。形式如下式：

目标函数 = Σ（观测值-理论值\) $$^2$$

观测值就是我们的多组样本，理论值就是我们的假设拟合函数。目标函数也就是在机器学习中常说的损失函数，我们的目标是得到使目标函数最小化时候的拟合函数的模型。举一个最简单的线性回归的简单例子，比如我们有m个只有一个特征的样本：

$$(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),...(x^{(m)},y^{(m)})$$

样本采用下面的拟合函数：

$$h_\theta(x)=\theta_0+\theta_1x$$

这样我们的样本有一个特征x，对应的拟合函数有两个参数$$\theta_0$$和$$\theta_1$$需要求出。

我们的目标函数为：

$$ J(\theta_0,\theta_1)=\sum_{i=1}^{m}(y^{(i)}-\theta_0-\theta_1x^{(i)})^2$$

用最小二乘法做什么呢，使$$J(\theta_0,\theta_1)$$最小，求出使$$J(\theta_0,\theta_1)$$最小时的$$\theta_0$$和$$\theta_1$$，这样拟合函数就得出了。

那么，最小二乘法怎么才能使$$J(\theta_0,\theta_1)$$最小呢？

# 2.最小二乘法的代数法解法

上面提到要使$$J(\theta_0,\theta_1)$$最小，方法就是对$$\theta_0$$和$$\theta_1$$分别来求偏导数，令偏导数为0，得到一个关于$$\theta_0$$和$$\theta_1$$的二元方程组。求解这个二元方程组，就可以得到$$\theta_0$$和$$\theta_1$$的值。下面我们具体看看过程。

J\($$\theta_0$$,$$\theta_1$$\)对$$\theta_0$$求导，得到如下方程：

$$\sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)}) = 0$$

$$J(\theta_0, \theta_1)$$对$$\theta_1$$求导，得到如下方程：

$$\sum\limits_{i=1}^{m}(y^{(i)} -  \theta_0 - \theta_1 x^{(i)})x^{(i)} = 0$$

①和②组成一个二元一次方程组，容易求出$$\theta_0$$和$$\theta_1$$的值：

$$\theta_0 = \sum\limits_{i=1}^{m}\big(x^{(i)})^2\sum\limits_{i=1}^{m}y^{(i)} - \sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}x^{(i)}y^{(i)} \Bigg/ n\sum\limits_{i=1}^{m}\big(x^{(i)})^2 - \big(\sum\limits_{i=1}^{m}x^{(i)})^2$$

$$\theta_1 = n\sum\limits_{i=1}^{m}x^{(i)}y^{(i)} - \sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}y^{(i)} \Bigg/ n\sum\limits_{i=1}^{m}\big(x^{(i)})^2 - \big(\sum\limits_{i=1}^{m}x^{(i)})^2$$

这个方法很容易推广到多个样本特征的线性拟合。

拟合函数表示为 hθ\(x1,x2,...xn\)=θ0+θ1x1+...+θnxnhθ\(x1,x2,...xn\)=θ0+θ1x1+...+θnxn, 其中θiθi\(i = 0,1,2... n\)为模型参数，xixi\(i = 0,1,2... n\)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征x0=1x0=1，这样拟合函数表示为：

hθ\(x0,x1,...xn\)=∑i=0nθixihθ\(x0,x1,...xn\)=∑i=0nθixi。

损失函数表示为：

J\(θ0,θ1...,θn\)=∑j=1m\(hθ\(x\(j\)0\),x\(j\)1,...x\(j\)n\)\)−y\(j\)\)\)2=∑j=1m\(∑i=0nθix\(j\)i−y\(j\)\)2J\(θ0,θ1...,θn\)=∑j=1m\(hθ\(x0\(j\)\),x1\(j\),...xn\(j\)\)\)−y\(j\)\)\)2=∑j=1m\(∑i=0nθixi\(j\)−y\(j\)\)2

利用损失函数分别对θiθi\(i=0,1,...n\)求导,并令导数为0可得：

∑j=0m\(∑i=0nθix\(j\)i−yj\)xji∑j=0m\(∑i=0nθixi\(j\)−yj\)xij= 0   \(i=0,1,...n\)

这样我们得到一个N+1元一次方程组，这个方程组有N+1个方程，求解这个方程，就可以得到所有的N+1个未知的θθ。

这个方法很容易推广到多个样本特征的非线性拟合。原理和上面的一样，都是用损失函数对各个参数求导取0，然后求解方程组得到参数值。这里就不累述了。

# 3.最小二乘法的矩阵法解法

矩阵法比代数法要简洁，且矩阵运算可以取代循环，所以现在很多书和机器学习库都是用的矩阵法来做最小二乘法。

这里用上面的多元线性回归例子来描述矩阵法解法。

假设函数hθ\(x1,x2,...xn\)=θ0+θ1x1+...+θnxnhθ\(x1,x2,...xn\)=θ0+θ1x1+...+θnxn的矩阵表达方式为：

hθ\(x\)=Xθhθ\(x\)=Xθ

其中， 假设函数hθ\(X\)hθ\(X\)为mx1的向量,θθ为nx1的向量，里面有n个代数法的模型参数。XX为mxn维的矩阵。m代表样本的个数，n代表样本的特征数。

损失函数定义为J\(θ\)=12\(Xθ−Y\)T\(Xθ−Y\)J\(θ\)=12\(Xθ−Y\)T\(Xθ−Y\)

其中YY是样本的输出向量，维度为mx1.1212在这主要是为了求导后系数为1，方便计算。

根据最小二乘法的原理，我们要对这个损失函数对θθ向量求导取0。结果如下式：

∂∂θJ\(θ\)=XT\(Xθ−Y\)=0∂∂θJ\(θ\)=XT\(Xθ−Y\)=0

这里面用到了矩阵求导链式法则，和两个矩阵求导的公式。

公式1：∂∂X\(XXT\)=2X∂∂X\(XXT\)=2X

公式2：∂∂θ\(Xθ\)=XT∂∂θ\(Xθ\)=XT

对上述求导等式整理后可得：

XTXθ=XTYXTXθ=XTY

两边同时左乘\(XTX\)−1\(XTX\)−1可得：

θ=\(XTX\)−1XTYθ=\(XTX\)−1XTY

这样我们就一下子求出了θθ向量表达式的公式，免去了代数法一个个去求导的麻烦。只要给了数据,我们就可以用θ=\(XTX\)−1XTYθ=\(XTX\)−1XTY算出θθ。

# 4.最小二乘法的局限性和适用场景

从上面可以看出，最小二乘法适用简洁高效，比梯度下降这样的迭代法似乎方便很多。但是这里我们就聊聊最小二乘法的局限性。

首先，最小二乘法需要计算XTXXTX的逆矩阵，有可能它的逆矩阵不存在，这样就没有办法直接用最小二乘法了，此时梯度下降法仍然可以使用。当然，我们可以通过对样本数据进行整理，去掉冗余特征。让XTXXTX的行列式不为0，然后继续使用最小二乘法。

第二，当样本特征n非常的大的时候，计算XTXXTX的逆矩阵是一个非常耗时的工作（nxn的矩阵求逆），甚至不可行。此时以梯度下降为代表的迭代法仍然可以使用。那这个n到底多大就不适合最小二乘法呢？如果你没有很多的分布式大数据计算资源，建议超过10000个特征就用迭代法吧。或者通过主成分分析降低特征的维度后再用最小二乘法。

第三，如果拟合函数不是线性的，这时无法使用最小二乘法，需要通过一些技巧转化为线性才能使用，此时梯度下降仍然可以用。

第四，讲一些特殊情况。当样本量m很少，小于特征数n的时候，这时拟合方程是欠定的，常用的优化方法都无法去拟合数据。当样本量m等于特征说n的时候，用方程组求解就可以了。当m大于n时，拟合方程是超定的，也就是我们常用与最小二乘法的场景了。

